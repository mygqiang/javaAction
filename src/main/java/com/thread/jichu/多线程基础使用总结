1. 线程和进程的区别
    一个应运程序对应一个进程,一个进程中可能有多个线程,可以说进程中的多线程是伪多线程,cpu的多线程是真的物理多线程.
2. 并发和并行的区别
    并行指同一时刻处理事情的能力,并发指单位时间处理事情的能力
3. java里的多线程认识
    1).java里的线程是共享协作试的
    2).开启线程的三种方式
       ①.继承Thread这个类: 不利:java是单继承的
       ②.实现Runnable接口: 益处:弥补了Thread的缺陷
       ③.实现Callable接口: 特性一,有返回值;特性二可以抛出异常.实质上是依靠java多线程设计模式中的Future模式
4. java多线程里的基本方法和5种状态
    1)线程启动方法
       start()是线程的启动方法,run()方法就是一个普通方法,只有掉用了start()方法jvm才会将线程和操作系统中实际的线程进行映射,再来执行run()方法;
        直接调用run()方法只是普通方法的调用
    2)停止线程方法
       stop()，resume(),suspend()这三个方法是已定不建议使用的,
       interrupt()方法方法中断一个线程,这种中断不是强制性的中断,只是修改了启动的线程中断状置为true,启动线程可以根据这个状态来自行处理是否中断
       static 的 interrupt()方法判断当前线程是否需要中断同时将中断位置置为false
       线程中如果出现InterruptedException异常会将中断状态置为false,为了保险起见要修改中断状态最好在catch中在掉用一次interrupt方法
    3)线程的5种状态
                   阻塞
       新建-->就绪------->运行-->死亡

    4)sleep(),join(),yield(),wait(),notify()/notifyAll()
       sleep()可以使线程睡眠有异常,持有的锁是不会释放的;
       join()线程等待,当前线程等待调运join()方法对象执行完成才开执行,有异常.
       wait()有异常,调运方法之前必须持有锁,调运了wait()方法之后锁会释放,当wait()方法返回的时候会重新持有锁.
       notify()/notifyAll() 没有异常 ,调运之前必须持有锁,调运这个方法本身不会释放锁
       yield()释放资源是当前线程回到就绪状态,没有异常,持有的锁是不会释放的;
5. 多线程基础的几个关键字和ThreadLocal,守护线程
      synchronized 内置锁 是一个重量级的锁(现在优化的好多了)   起到互斥的作用另一个是起到内存可见性
      volatile 第一个作用是内存可见 第二个不参与排序  第三如果是写操作他会试其他cpu缓存失效
            适用于一个线程写多个线程读的场景
      ThreadLocal  线程变量 每个线程的私有属性,可以理解为一个map ,类型Map<Thread,Object>
      守护线程  和主线程共生, 守护线程中的finally不能保证一定会执行





